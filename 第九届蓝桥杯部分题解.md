###2.明码
一共16行，布局是：
第1字节，第2字节
第3字节，第4字节
....
第31字节, 第32字节
这道题目是给你一段多个汉字组成的信息，每个汉字用32个字节表示，这里给出了字节作为有符号整数的值。
题目的要求隐藏在这些信息中。你的任务是复原这些汉字的字形，从中看出题目的要求，并根据要求填写答案。
这段信息是（一共10个汉字）：
4,0,4,0,4,0,4,32,-1,-16,4,32,4,32,4,32,4,32,4,32,8,32,8,32,16,34,16,34,32,30,-64,0,
16,64,16,64,34,68,127,126,66,-124,67,4,66,4,66,-124,126,100,66,36,66,4,66,4,66,4,126,4,66,40,0,16,
4,0,4,0,4,0,4,32,-1,-16,4,32,4,32,4,32,4,32,4,32,8,32,8,32,16,34,16,34,32,30,-64,0,
0,-128,64,-128,48,-128,17,8,1,-4,2,8,8,80,16,64,32,64,-32,64,32,-96,32,-96,33,16,34,8,36,14,40,4,
4,0,3,0,1,0,0,4,-1,-2,4,0,4,16,7,-8,4,16,4,16,4,16,8,16,8,16,16,16,32,-96,64,64,
16,64,20,72,62,-4,73,32,5,16,1,0,63,-8,1,0,-1,-2,0,64,0,80,63,-8,8,64,4,64,1,64,0,-128,
0,16,63,-8,1,0,1,0,1,0,1,4,-1,-2,1,0,1,0,1,0,1,0,1,0,1,0,1,0,5,0,2,0,
2,0,2,0,7,-16,8,32,24,64,37,-128,2,-128,12,-128,113,-4,2,8,12,16,18,32,33,-64,1,0,14,0,112,0,
1,0,1,0,1,0,9,32,9,16,17,12,17,4,33,16,65,16,1,32,1,64,0,-128,1,0,2,0,12,0,112,0,
0,0,0,0,7,-16,24,24,48,12,56,12,0,56,0,-32,0,-64,0,-128,0,0,0,0,1,-128,3,-64,1,-128,0,0
题解：
```cpp
#include<bits/stdc++.h>   

using namespace std;
int num[][32]=
{
	{4,0,4,0,4,0,4,32,-1,-16,4,32,4,32,4,32,4,32,4,32,8,32,8,32,16,34,16,34,32,30,-64,0},
	{16,64,16,64,34,68,127,126,66,-124,67,4,66,4,66,-124,126,100,66,36,66,4,66,4,66,4,126,4,66,40,0,16},
	{4,0,4,0,4,0,4,32,-1,-16,4,32,4,32,4,32,4,32,4,32,8,32,8,32,16,34,16,34,32,30,-64,0},
	{0,-128,64,-128,48,-128,17,8,1,-4,2,8,8,80,16,64,32,64,-32,64,32,-96,32,-96,33,16,34,8,36,14,40,4},
	{4,0,3,0,1,0,0,4,-1,-2,4,0,4,16,7,-8,4,16,4,16,4,16,8,16,8,16,16,16,32,-96,64,64},
	{16,64,20,72,62,-4,73,32,5,16,1,0,63,-8,1,0,-1,-2,0,64,0,80,63,-8,8,64,4,64,1,64,0,-128},
	{0,16,63,-8,1,0,1,0,1,0,1,4,-1,-2,1,0,1,0,1,0,1,0,1,0,1,0,1,0,5,0,2,0},
	{2,0,2,0,7,-16,8,32,24,64,37,-128,2,-128,12,-128,113,-4,2,8,12,16,18,32,33,-64,1,0,14,0,112,0},
	{1,0,1,0,1,0,9,32,9,16,17,12,17,4,33,16,65,16,1,32,1,64,0,-128,1,0,2,0,12,0,112,0},
	{0,0,0,0,7,-16,24,24,48,12,56,12,0,56,0,-32,0,-64,0,-128,0,0,0,0,1,-128,3,-64,1,-128,0,0}	
};  //建立二维数组 

void change()
{
	for(int i=0;i<10;i++) //遍历十个汉字 
	{
		for(int j=0;j<32;j++)
		{
			for(int k=8;k>=0;k--)  //取8位  
				cout<<((num[i][j]>>k)&1);  //按位与1 
			if((j+1)%2==0)
				cout<<endl;	
		}
		cout<<endl;
	}
}

int main(void){  

   change();
   long long num;
	num=pow(9,9);
   cout<<num<<endl;
   return 0;	
}  
```

###3.乘积尾零
如下的10行数据，每行有10个整数，请你求出它们的乘积的末尾有多少个零？
5650 4542 3554 473 946 4114 3871 9073 90 4329 
2758 7949 6113 5659 5245 7432 3051 4434 6704 3594 
9937 1173 6866 3397 4759 7557 3070 2287 1453 9899 
1486 5722 3135 1170 4014 5510 5120 729 2880 9019 
2049 698 4582 4346 4427 646 9742 7340 1230 7683 
5693 7015 6887 7381 4172 4341 2909 2027 7355 5649 
6701 6645 1671 5978 2704 9926 295 3125 3878 6785 
2066 4247 4800 1578 6652 4616 1113 6205 3264 2915 
3966 5291 2904 1285 2193 1428 2265 8730 9436 7074 
689 5510 8243 6114 337 4096 8199 7313 3685 211
注意：需要提交的是一个整数，表示末尾零的个数。不要填写任何多余内容。
```cpp
#include < bits/stdc++.h >
/*  
	4*5=20
    2*2  5*1
    num2=2;num5=1
    min(num2,num5)=1
    10*10=100
    2*5 2*5 
    num2=2;num5=2
    min(num2,num5)=2
    
*/

using namespace std;
int main()
{
  int n;
  int num1 = 0;
  int num2 = 0;
  
  for(int i=0;i<100;i++)
  {
  	cin>>n;
  	while(true)
  	{
  		if(n % 2 == 0){
        n /= 2;
        num1++;
      }
       else if(n % 5 == 0){
        n /= 5;
        num2++;
      }
      else
        break;
	
  	}
}
  cout<<min(num1,num2)<<endl;
  return 0;
}

```


###7.标题：螺旋折线
如图p1.png所示的螺旋折线经过平面上所有整点恰好一次。
对于整点(X, Y)，我们定义它到原点的距离dis(X, Y)是从原点到(X, Y)的螺旋折线段的长度。
例如dis(0, 1)=3, dis(-2, -1)=9
给出整点坐标(X, Y)，你能计算出dis(X, Y)吗？
 
 
```cpp

#include <bits/stdc++.h>
using namespace std;

/*先判断第几圈再模拟*/ 


int xx[]={-1,0,1,0};    //X轴左上右下
int yy[]={0,1,0,-1};	//Y轴左上右下

long long  Count;    //总步数计数器 

int Left=1;    // 第一圈 4个方向初值   
int Up=1;
int Right=2;
int Down=2;


int main(void)
{
    long long x,y;
    cin>>x>>y;
    
    long long re=max(abs(x),abs(y)); //第几圈
   //	cout<<"re="<<re<<endl; 
	 long long X,Y;
	 X= re-1; //起点X坐标 
	 Y=-X;  //起点Y坐标 
	 
	// cout<<"起点坐标 "<<X<<" "<<Y<<endl; 
	 
	 Left+=(re-1)*2;
	 Up+=(re-1)*2;
	 Right+=(re-1)*2;
	 Down+=(re-1)*2;
    
    long long a=(re-1)*(4*re-2);  //  (n-1)*(4n-2)
    //cout<<"a="<<a<<endl; 
    
    int c;  
    int flag=0;    //标志 
    
    if( x==0 && y==0 )
    {
       cout<<0<<endl;
        return 0;
    }
        else
        {
            int i;
            for(i=0;i<=3;i++)
            {
                c=0;
                if(i==0)    //左
                {
                    while(c<Left)
                    { 
                        X+=xx[i];
                        Y+=yy[i];
                        Count++;    //加步数
                        if(X==x && Y==y)    //走了以后判断
                        { 
                            flag=1;
                            break;
                        } 
                        c++;
                    } 
                    if(flag==1)
                        break;
                    Left+=2;    //步数+2 
                }
                if(i==1)    //上 
                {
                    while(c<Up)
                    { 
                        X+=xx[i];
                        Y+=yy[i];
                        Count++;
                        if(X==x && Y==y)
                        { 
                            flag=1;
                            break;
                        } 
                        c++;
                    }
                    if(flag==1)
                        break;
                    Up+=2; 
                }
                if(i==2)    //右 
                {
                    while(c<Right)
                    { 
                        X+=xx[i];
                        Y+=yy[i];
                        Count++;
                        if(X==x && Y==y)
                        { 
                            flag=1;
                            break;
                        } 
                        c++;
                    }
                    if(flag==1)
                        break;
                    Right+=2; 
                }
                if(i==3)    //下 
                {
                    while(c<Down)
                    { 
                        X+=xx[i];
                        Y+=yy[i];
                        Count++;
                        if(X==x && Y==y)
                        { 
                            flag=1;
                            break;
                        } 
                        c++;
                    }
                    if(flag==1)
                        break;
                    Down+=2; 
                }
                if(i==3)    //再次相加
                    i=-1;
            }
        }
   
    cout<<Count+a<<endl;
    return 0;
}
```


##8.标题：日志统计
小明维护着一个程序员论坛。现在他收集了一份”点赞”日志，日志共有N行。其中每一行的格式是：
ts id
表示在ts时刻编号id的帖子收到一个”赞”。
现在小明想统计有哪些帖子曾经是”热帖”。如果一个帖子曾在任意一个长度为D的时间段内收到不少于K个赞，小明就认为这个帖子曾是”热帖”。
具体来说，如果存在某个时刻T满足该帖在[T, T+D)这段时间内(注意是左闭右开区间)收到不少于K个赞，该帖就曾是”热帖”。
给定日志，请你帮助小明统计出所有曾是”热帖”的帖子编号。
【输入格式】
第一行包含三个整数N、D和K。  
以下N行每行一条日志，包含两个整数ts和id。  

对于50%的数据，1 <= K <= N <= 1000  
对于100%的数据，1 <= K <= N <= 100000 0 <= ts <= 100000 0 <= id <= 100000  

【输出格式】
按从小到大的顺序输出热帖id。每个id一行。  

【输入样例】
7 10 2  
0 1  
0 10    
10 10  
10 1  
9 1
100 3  
100 3  

【输出样例】
1  
3  



```cpp


#include <bits/stdc++.h>
using namespace std;
int n,d,k;  
const int maxn=100000+5;  
vector<int> arr[maxn];  //vector型数组  
  
bool judge(int id)  //对每个id进行判断 
{  
    int len=arr[id].size();  
    if(len<k)       //总的点赞次数小于k 直接返回false 
        return false;   
    sort(arr[id].begin(),arr[id].end());  //对时间进行排序 
    int start=0;int end=0;    // 定义两个整型指针 指向开头和结尾。 
    int cnt=0;  
    while(start<=end && end<len)  
    {  
        cnt++;  
        if(cnt>=k)  
        {  
            if(arr[id][end]-arr[id][start]<d) //注意是小于(题中说是前闭后开区间 )  [T,T+D) 
                return true;  
            else  //如果if语句不成立，那么你再去后移end，也是不符要求的，所以该后移start了   
            {  
                cnt--;  
                start++;  
            }   
        }  
        end++;  
    }   
    return false;  
}    
  
int main()  
{  
	int ans[maxn];
    cin>>n>>d>>k;  
    for(int i=1;i<=n;i++)  
    {  
        int ts,id;  
        cin>>ts>>id;  
        arr[id].push_back(ts);  
    }  
    
    int num=0;//计数器 
    
	for(int i=1;i<maxn;i++)  //存放对应的ID 
	{
		if(judge(i))
			ans[num++]=i;
	}
	
	
	for(int i=0;i<num;i++)
	{
		cout<<ans[i]<<endl;
	}
	 return 0;
    
}  
```